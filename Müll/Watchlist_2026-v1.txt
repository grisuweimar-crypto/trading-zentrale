import yfinance as yf
import pandas as pd
import numpy as np
import os
import requests
import time
import logging
from datetime import datetime
import gspread
from oauth2client.service_account import ServiceAccountCredentials


try:
    # --- CLOUD IMPORT ROBUST ---
    scope = [
        "https://spreadsheets.google.com/feeds",
        "https://www.googleapis.com/auth/drive"
    ]
    creds = ServiceAccountCredentials.from_json_keyfile_name("googlekey.json", scope)
    client = gspread.authorize(creds)
    sheet = client.open("TradingZentraleCloud")

    # Watchlist-Worksheet robust lesen
    wswl = sheet.worksheet("Watchlist")

    # Rohdaten holen (inkl. Leerzeilen), leere Zeilen rausfiltern
    raw_wl = wswl.get_all_values()
    if not raw_wl or len(raw_wl) < 2:
        print("Warnung: Watchlist-Sheet ist leer oder hat nur Header.")
        df_wl = pd.DataFrame()
    else:
        header = raw_wl[0]
        rows = [r for r in raw_wl[1:] if any(str(x).strip() for x in r)]
        df_wl = pd.DataFrame(rows, columns=header)

    # Portfolio-Worksheet robust lesen
    wspf = sheet.worksheet("Portfolio")
    raw_pf = wspf.get_all_values()
    if not raw_pf or len(raw_pf) < 2:
        print("Warnung: Portfolio-Sheet ist leer oder hat nur Header.")
        df_pf = pd.DataFrame()
    else:
        header_pf = raw_pf[0]
        rows_pf = [r for r in raw_pf[1:] if any(str(x).strip() for x in r)]
        df_pf = pd.DataFrame(rows_pf, columns=header_pf)

    # Datentyp-Korrektur f√ºr numerische WL-Spalten
    for col in ["MCChance", "Upside", "PE", "Debt", "DivRendite", "Wachstum", "Marge", "Score"]:
        if col in df_wl.columns:
            df_wl[col] = pd.to_numeric(df_wl[col], errors="coerce").fillna(0)

    print("Cloud-Daten geladen. WL:", len(df_wl), ", PF:", len(df_pf))

except Exception as e:
    print("Cloud-Ladefehler", e)
    # Skript nicht hart beenden ‚Äì lieber mit leeren DataFrames weiter
    df_wl = pd.DataFrame()
    df_pf = pd.DataFrame()


# Logging aus
logging.getLogger('yfinance').setLevel(logging.CRITICAL)

# --- KONFIGURATION ---
excel_file = r"C:\Users\CW\OneDrive\Desktop\Watchlist Master 2026-voll.xlsx"
TELEGRAM_TOKEN = "8507338681:AAGyiWZ4coOrwVemJujt-uT2uZmT6V66NqQ" 
CHAT_ID = "1369830507"

# --- EINSTELLUNGEN ---
MC_DAYS = 30
MC_SIMULATIONS = 500

# Gewichte (Sync mit Dashboard)
STD_ANALYST = 10
STD_UPSIDE  = 10
STD_PE      = 15
STD_DEBT    = 5
STD_DIV     = 5
STD_GROWTH  = 10
STD_MARGIN  = 10
STD_MC      = 20
STD_ELLIO = 0  # Gewicht f√ºr Elliott-Confidence (0‚Äì50)

print("üöÄ STARTE SCANNER (V24 - Mit OneDrive-Geduld)...")

# --- TELEGRAM ---
def telegram_send(message):
    url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
    data = {"chat_id": CHAT_ID, "text": message, "parse_mode": "Markdown"}
    try:
        requests.post(url, data=data)
    except Exception as e:
        print(f"‚ùå Telegram Fehler: {e}")

# --- MATHE ---

def zigzag(prices, threshold=0.03):
    swings = []
    if len(prices) == 0: return swings
    last_pivot = prices[0]
    last_type = None 

    for i, price in enumerate(prices[1:], start=1):
        change = (price - last_pivot) / last_pivot
        if last_type != 'high' and change >= threshold:
            swings.append((i, price, 'high'))
            last_pivot = price
            last_type = 'high'
        elif last_type != 'low' and change <= -threshold:
            swings.append((i, price, 'low'))
            last_pivot = price
            last_type = 'low'
    return swings

def detect_elliott_patterns(swings_input):
    if len(swings) < 4: return None

    # Letzte Swings analysieren
    last = swings[-6:] 
    types = [s[2] for s in last]
    
    # MUSTER A: Klassischer 5-Wellen Impuls (Welle 5 Finale)
    if len(last) >= 6 and types[-6:] == ['low', 'high', 'low', 'high', 'low', 'high']:
        w3 = last[3][1] - last[2][1]
        w1 = last[1][1] - last[0][1]
        w5 = last[5][1] - last[4][1]
        # Welle 3 darf nicht die k√ºrzeste sein
        if w3 > min(w1, w5):
            return {"type": "IMPULS (W5)", "confidence": 0.85, "entry": last[4][1]}

    # MUSTER B: Start der Welle 3 (Der profitabelste Einstieg)
    # Sequenz: Low -> High (W1) -> Higher Low (W2) -> aktueller Anstieg
    if len(last) >= 3 and types[-3:] == ['low', 'high', 'low']:
        if last[-1][1] > last[-3][1]: # Higher Low best√§tigt
            return {"type": "WELLE 3 START", "confidence": 0.75, "entry": last[-2][1]}

    # MUSTER C: A-B-C Korrektur abgeschlossen
    # Sequenz: High -> Low (A) -> Lower High (B) -> Lower Low (C)
    if len(last) >= 4 and types[-4:] == ['high', 'low', 'high', 'low']:
        if last[-1][1] < last[-3][1]: # C tiefer als A
            return {"type": "ABC KORREKTUR", "confidence": 0.65, "entry": last[-2][1]}

    return None


def calculate_monte_carlo_prob(history):
    if len(history) < MC_DAYS: return 0
    try:
        returns = history['Close'].pct_change().dropna()
        mean = returns.mean()
        std = returns.std()
        simulations = np.random.normal(mean, std, (MC_DAYS, MC_SIMULATIONS))
        paths = (1 + simulations).cumprod(axis=0)
        final_prices = paths[-1] * history['Close'].iloc[-1]
        win_prob = np.mean(final_prices > history['Close'].iloc[-1]) * 100
        return win_prob
    except: return 0

def calculate_score(data_row):
    def safe_float(val):
        try: return float(val)
        except: return 0.0

    s_score = 0
    t_sig = str(data_row.get('Typ', ''))
    
    # Basis-Score
    if "DOPPEL" in t_sig:
        s_score += 100
    else:
        s_score += 50

    # MC & Analysten
    s_score += safe_float(data_row.get('MC_Chance', 0)) * (STD_MC / 100)
    rec_key = str(data_row.get('AnalystRec', '')).lower()
    if 'buy' in rec_key or 'strong' in rec_key:
        s_score += STD_ANALYST

    # Upside & Fundamentaldaten
    up_val = safe_float(data_row.get('Upside', 0))
    if up_val > 5: s_score += STD_UPSIDE
    elif up_val < 0: s_score -= STD_UPSIDE

    pe_val = safe_float(data_row.get('PE', 999))
    if 0 < pe_val < 25: s_score += STD_PE
    elif pe_val > 60: s_score -= STD_PE

    debt_val = safe_float(data_row.get('Debt', 0))
    if debt_val < 80: s_score += STD_DEBT
    elif debt_val > 150: s_score -= STD_DEBT

    if safe_float(data_row.get('DivRendite', 0)) > 2.0: s_score += STD_DIV
    if safe_float(data_row.get('Wachstum', 0)) > 5: s_score += STD_GROWTH
    if safe_float(data_row.get('Marge', 0)) > 0: s_score += STD_MARGIN

    # Elliott Confidence
    e_conf = safe_float(data_row.get('Elliott_Confidence', 0))
    s_score += e_conf * STD_ELLIO 

    return s_score

def elliott_wave_signal(row, symbol):
    try:
        data = yf.download(symbol, period="6mo")
        if len(data) > 50:
            high = data['High'].tail(60).max()
            low = data['Low'].tail(60).min()
            range_size = high - low
            elliott_entry = high - range_size * 0.5  # Fib 50%
            kurs = float(row['Akt. Kurs [‚Ç¨]'])
            abstand = (kurs - elliott_entry) / kurs * 100
            
            if abs(abstand) < 10:
                return "üî• ELLIOTT KAUFEN", elliott_entry
            return "‚è≥ ELLIOTT WARTEN", elliott_entry
    except:
        pass
    return "FEHLER", 0


# --- SYMBOL MAPPING ---
def get_symbol(name, isin, asset_type='STOCK'):
    n = str(name).upper()
    if asset_type == 'CRYPTO':
        if 'BTC' in n: return 'BTC-EUR'
        if 'ETH' in n: return 'ETH-EUR'
        if 'SOL' in n: return 'SOL-EUR'
        if 'XRP' in n: return 'XRP-EUR'
        if 'ADA' in n: return 'ADA-EUR'
        return f"{n}-EUR"

    if 'UNITEDHEALTH' in n: return 'UNH.F'
    if 'INGREDION' in n: return 'CHI.F'
    if 'PHILIP MORRIS' in n: return '4I1.F'
    if 'JOHNSON' in n: return 'JNJ.F'
    if 'PROCTER' in n: return 'PRG.F'
    if 'COCA' in n: return 'CCC3.F'
    if 'PEPSI' in n: return 'PEP.F'
    if 'XIAOMI' in n: return '3CP.F'     
    if 'BYD' in n: return 'BY6.F'        
    if 'ALIBABA' in n: return 'AHLA.F'   
    if 'JD.COM' in n: return '099.F'
    if 'NIO' in n: return 'N3IA.F'
    if 'TENCENT' in n: return 'NNnD.F'
    if 'VALE' in n: return 'CVLC.F'      
    if 'B2GOLD' in n: return 'A2D.F'
    if 'AURORA' in n: return '21P.F'
    if 'CANOPY' in n: return '11L1.F'
    if 'NEL' in n: return 'D7G.F'        
    if 'NOVO' in n: return 'NOVC.DE'      
    if 'PAYPAL' in n: return '2PP.F'
    if 'MICROSOFT' in n: return 'MSF.F'
    if 'APPLE' in n: return 'APC.F'
    if 'TESLA' in n: return 'TL0.F'
    if 'AMAZON' in n: return 'AMZ.F'
    if 'NVIDIA' in n: return 'NVD.F'
    if 'PALANTIR' in n: return 'PTX.F'
    if 'NIKE' in n: return 'NKE.F'
    if 'CHEVRON' in n: return 'CHV.F'
    if 'CENTENE' in n: return 'C26.F'
    if 'ALLIANZ' in n: return 'ALV.DE'
    if 'BASF' in n: return 'BAS.DE'
    if 'MERCEDES' in n: return 'MBG.DE'
    if 'SAP' in n: return 'SAP.DE'
    if 'TELEKOM' in n: return 'DTE.DE'
    if 'SIEMENS' in n: return 'SIE.DE'
    if 'BAYER' in n: return 'BAYN.DE'
    if 'VONOVIA' in n: return 'VNA.DE'
    if 'FRESENIUS' in n: return 'FME.DE'
    if 'SUSS' in n: return 'SMHN.DE'
    if 'MUENCHENER' in n: return 'MUV2.DE'
    if 'INFINEON' in n: return 'IFX.DE'
    if 'DHL' in n: return 'DHL.DE'
    if 'MINISO' in n: return 'MNS.F'
    if 'RELIANCE' in n: return 'RIGD.F' 
    if 'FIRST SOLAR' in n: return 'F3A.F'
    if 'ALPHABET' in n: return 'GOOGL'


    if str(isin).startswith('US'): return str(isin)
    return ""

# --- HAUPTPROGRAMM ---
# --- CLOUD IMPORT ---
try:
    # 1. Verbindung zur Cloud aufbauen
    scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
    creds = ServiceAccountCredentials.from_json_keyfile_name('google_key.json', scope)
    client = gspread.authorize(creds)
    sheet = client.open("Trading_Zentrale_Cloud")
    
    # 2. Daten direkt aus Google Sheets laden
    df_wl = pd.DataFrame(sheet.worksheet("Watchlist").get_all_records())
    df_pf = pd.DataFrame(sheet.worksheet("Portfolio").get_all_records())
    
    # 3. Datenformate korrigieren
    for col in ['MC_Chance', 'Upside', 'PE', 'Debt', 'DivRendite', 'Wachstum', 'Marge']:
        if col in df_wl.columns:
            df_wl[col] = pd.to_numeric(df_wl[col], errors='coerce').fillna(0)
            
    print(f"‚úÖ Cloud-Daten geladen. WL: {len(df_wl)}, PF: {len(df_pf)}")

except Exception as e:
    print(f"‚ùå Cloud-Ladefehler: {e}")
    exit()

# 1. WATCHLIST SCAN
print("\nüî≠ Scanne Watchlist...")

# --- WATCHLIST SCAN (mit Elliott) ---
print("\nüî≠ Scanne Watchlist...")

# Spalten f√ºr Elliott vorbereiten
for c in ['Elliott_Signal', 'Elliott_Confidence', 'Elliott_Entry']:
    if c not in df_wl.columns:
        df_wl[c] = 0 if 'Confidence' in c else "-"

for idx, row in df_wl.iterrows():
    try:
        symbol = get_symbol(row.get('Name'), row.get('ISIN'), 'STOCK')
        if not symbol:
            continue

        t = yf.Ticker(symbol)
        try:
            price = t.fast_info.last_price
        except:
            h = t.history(period='5d')
            if h.empty:
                raise ValueError("Kein Preis")
            price = h['Close'].iloc[-1]

        info = t.info
        hist = t.history(period=f"{MC_DAYS+10}d")
        if hist.empty or 'Close' not in hist:
            raise ValueError("Keine Kursdaten")

        # üîπ Elliott Analyse (√úberarbeitet)
        prices = hist['Close'].values
        if len(prices) > 40:
            swings = zigzag(prices, threshold=0.03) # 3% Filter
            elliott = detect_elliott_patterns(swings) # Neue Kombi-Funktion

            if elliott:
                df_wl.at[idx, 'Elliott_Signal'] = elliott['type']
                df_wl.at[idx, 'Elliott_Confidence'] = elliott['confidence']
                df_wl.at[idx, 'Elliott_Entry'] = elliott['entry']
            else:
                df_wl.at[idx, 'Elliott_Signal'] = "SUCHE..."
                df_wl.at[idx, 'Elliott_Confidence'] = 0
                df_wl.at[idx, 'Elliott_Entry'] = None

        # üîπ Fundamentale Daten
        if price > 0:
            df_wl.at[idx, 'Akt. Kurs [‚Ç¨]'] = price

        df_wl.at[idx, 'PE'] = info.get('trailingPE', 999)
        if info.get('targetMeanPrice') and price > 0:
            df_wl.at[idx, 'Upside'] = ((info.get('targetMeanPrice') - price) / price) * 100

        df_wl.at[idx, 'AnalystRec'] = info.get('recommendationKey', 'none')
        d_raw = info.get('dividendYield', 0)
        if d_raw:
            # Korrektur: Wenn yf 0.04 liefert -> *100. Wenn es 4.5 liefert -> lassen.
            div_val = d_raw * 100 if d_raw < 0.5 else d_raw
            if div_val < 30: # Alles √ºber 30% ist meist ein Datenfehler
                df_wl.at[idx, 'DivRendite'] = div_val
        df_wl.at[idx, 'Marge'] = info.get('profitMargins', 0) * 100 if info.get('profitMargins') else 0
        df_wl.at[idx, 'Wachstum'] = info.get('revenueGrowth', 0) * 100 if info.get('revenueGrowth') else 0
        df_wl.at[idx, 'Debt'] = info.get('debtToEquity', 0)
        df_wl.at[idx, 'ProfiZiel'] = info.get('targetMeanPrice', 0)

        # üîπ Monte Carlo
        mc = calculate_monte_carlo_prob(hist)
        if mc > 0:
            df_wl.at[idx, 'MC_Chance'] = mc

        # üîπ Score Berechnen inkl. Elliott
        df_wl.at[idx, 'Score'] = calculate_score(df_wl.loc[idx])

    except Exception as e:
        print(f"‚ö†Ô∏è Fehler bei {row.get('Name')}: {e}")
        continue



# 2. PORTFOLIO SCAN
print("\nüíº Scanne Portfolio...")
pf_alarms = []
for idx, row in df_pf.iterrows():
    asset_type = row.get('AssetType', 'STOCK')
    symbol = get_symbol(row['Name'], row.get('ISIN'), asset_type)
    if not symbol: continue
    try:
        t = yf.Ticker(symbol)
        try: kurs = t.fast_info.last_price
        except: kurs = t.history(period='1d')['Close'].iloc[-1]
        
        if kurs > 0: df_pf.at[idx, 'Akt. Kurs [‚Ç¨]'] = kurs
        
        if asset_type == 'STOCK':
            # Wir pr√ºfen, ob schon manuell etwas eingetragen wurde
            current_div = row.get('DivRendite', 0)
            if pd.isna(current_div) or current_div == 0: 
                d = t.info.get('dividendYield', 0)
                if d:
                    # Gleiche Korrektur wie oben
                    div_fix = d * 100 if d < 0.5 else d
                    if div_fix < 30:
                        df_pf.at[idx, 'DivRendite'] = div_fix
        sl = row.get('Stop Loss')
        tp = row.get('Take Profit')
        if pd.notna(sl) and kurs <= sl:
            pf_alarms.append(f"üö® STOP LOSS: {row['Name']} ({kurs:.2f} < {sl})")
            df_pf.at[idx, 'Warnung'] = "STOP LOSS!"
        elif pd.notna(tp) and kurs >= tp:
            pf_alarms.append(f"üí∞ TAKE PROFIT: {row['Name']} ({kurs:.2f} > {tp})")
            df_pf.at[idx, 'Warnung'] = "ZIEL ERREICHT!"
        else:
            df_pf.at[idx, 'Warnung'] = None
    except: pass

# 3. SPEICHERN (MIT WIEDERHOLUNG)
print("\nüíæ Speichern...")
df_pf['Aktueller Wert'] = df_pf['Anzahl'] * df_pf['Akt. Kurs [‚Ç¨]']
df_pf['Invest'] = df_pf['Anzahl'] * df_pf['Kaufkurs']
df_pf['G/V'] = df_pf['Aktueller Wert'] - df_pf['Invest']
total_wert = df_pf['Aktueller Wert'].sum()
total_gv = df_pf['G/V'].sum()

save_success = False
max_retries = 5

# --- SPEICHERN NUR NOCH IN DER CLOUD ---
def uploadtocloud(df_watchlist: pd.DataFrame, df_portfolio: pd.DataFrame):
    try:
        print("--- CLOUD-UPLOAD ---")
        scope = [
            "https://spreadsheets.google.com/feeds",
            "https://www.googleapis.com/auth/drive"
        ]
        creds = ServiceAccountCredentials.from_json_keyfile_name("googlekey.json", scope)
        client = gspread.authorize(creds)
        sheet = client.open("TradingZentraleCloud")

        # 1. Watchlist √ºbertragen
        wswl = sheet.worksheet("Watchlist")
        wswl.clear()

        if df_watchlist is not None and not df_watchlist.empty:
            df_wl_clean = df_watchlist.copy()
            # Inf -> NaN, dann NaN -> ""
            df_wl_clean = df_wl_clean.replace([np.inf, -np.inf], np.nan).fillna("")
            # Alles in Strings f√ºr JSON-Sicherheit
            data_wl = [df_wl_clean.columns.values.tolist()] + df_wl_clean.astype(str).values.tolist()
            wswl.update("A1", data_wl)

        # 2. Portfolio √ºbertragen
        wspf = sheet.worksheet("Portfolio")
        wspf.clear()

        if df_portfolio is not None and not df_portfolio.empty:
            df_pf_clean = df_portfolio.copy()
            df_pf_clean = df_pf_clean.replace([np.inf, -np.inf], np.nan).fillna("")
            data_pf = [df_pf_clean.columns.values.tolist()] + df_pf_clean.astype(str).values.tolist()
            wspf.update("A1", data_pf)

        print("Cloud-Update erfolgreich! Daten sind jetzt online verf√ºgbar.")

    except Exception as e:
        print("Cloud-Fehler", e)


if save_success:
    # --- TELEGRAM ---
    warn_text = "Keine" if not pf_alarms else "\n".join(pf_alarms)
    msg_depot = (
        f"üè¶ **DEPOT UPDATE**\n"
        f"Depot: {total_wert:,.2f} ‚Ç¨\n"
        f"G/V: {total_gv:,.2f} ‚Ç¨\n"
        f"Warnsignale: {warn_text}"
    )
    telegram_send(msg_depot)
    
    # --- TOP 3 SICHERHEIT ---
if df_wl is None or df_wl.empty:
    print("Keine Top 3: Watchlist ist leer.")
else:
    if "Score" not in df_wl.columns:
        print("Keine Top 3: Spalte 'Score' fehlt.")
    else:
        # Score auf numerisch zwingen, Fehler -> 0
        df_wl["Score"] = pd.to_numeric(df_wl["Score"], errors="coerce").fillna(0)

        # Nur Zeilen mit sinnvollem Score behalten (z.B. Score != 0 optional)
        df_valid = df_wl.copy()

        if df_valid.empty:
            print("Keine Top 3: keine g√ºltigen Score-Daten.")
        else:
            top3 = df_valid.sort_values(by="Score", ascending=False).head(3)
            if top3.empty:
                print("Keine Top 3: nach Sortierung keine Daten.")
            else:
                for i, (idx, row) in enumerate(top3.iterrows()):
                    medals = ["ü•á", "ü•à", "ü•â"]
                    einstieg = row.get("Auto-Einstieg", 0)
                    if pd.isna(einstieg) or einstieg == 0:
                        einstieg = row.get("Akt. Kurs", 0)
                    profiziel = row.get("ProfiZiel", 0)
                    if pd.isna(profiziel) or profiziel == 0:
                        pzieltxt = "na"
                    else:
                        pzieltxt = f"{profiziel:.2f}"
                    deinziel = row.get("Ziel", "na")
                    if pd.isna(deinziel):
                        deinziel = "na"

                    msgtop = (
                        f"{medals[i]} {row['Name']} "
                        f"Score {int(row.get('Score', 0))} | "
                        f"Einstieg {float(einstieg):.2f} | "
                        f"Aktuell {float(row.get('Akt. Kurs', 0)):.2f} | "
                        f"Dein Ziel {deinziel} | "
                        f"Profi-Ziel {pzieltxt}"
                    )
                    telegramsend(msgtop)

    print("üöÄ Fertig.")
else:
    print("‚ùå‚ùå‚ùå KONNTE NICHT SPEICHERN. KEIN TELEGRAM GESENDET. ‚ùå‚ùå‚ùå")
    print("Bitte pr√ºfe, ob Excel oder OneDrive die Datei blockiert.")
    
# ==============================================================================
# üìà HISTORIE IN GOOGLE SHEETS SPEICHERN (IMMER AUSF√úHREN)
# ==============================================================================
print("\nüìà Aktualisiere Depot-Historie in der Cloud...")
try:
    # 1. Tabellenblatt "Historie" ansteuern oder erstellen
    try:
        ws_hist = sheet.worksheet("Historie")
    except:
        # Falls das Blatt fehlt, wird es neu erstellt
        ws_hist = sheet.add_worksheet(title="Historie", rows="2000", cols="2")
        ws_hist.append_row(["Datum", "Wert"])
        print("üìÅ Neues Blatt 'Historie' wurde angelegt.")

    # 2. Aktuellen Depotwert berechnen
    df_pf['Anzahl_Num'] = pd.to_numeric(df_pf['Anzahl'], errors='coerce').fillna(0)
    df_pf['Kurs_Num'] = pd.to_numeric(df_pf['Akt. Kurs [‚Ç¨]'], errors='coerce').fillna(0)
    aktueller_gesamtwert = (df_pf['Anzahl_Num'] * df_pf['Kurs_Num']).sum()

    # 3. Zeitstempel und Wert hinzuf√ºgen
    zeitpunkt = datetime.now().strftime("%d.%m.%Y %H:%M")
    ws_hist.append_row([zeitpunkt, round(float(aktueller_gesamtwert), 2)])
    
    print(f"‚úÖ Historie aktualisiert: {zeitpunkt} -> {aktueller_gesamtwert:.2f} ‚Ç¨")

except Exception as e:
    print(f"‚ö†Ô∏è Historie-Fehler: {e}")

# Ganz am Ende zur Best√§tigung
print("\nüöÄ SCANNER-AUTOPILOT ERFOLGREICH BEENDET.")





